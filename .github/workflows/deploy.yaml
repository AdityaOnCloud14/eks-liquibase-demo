name: Liquibase Multi-Environment Deployment Pipeline

on:
  workflow_dispatch:
    inputs:
      environment:
        description: 'Target environment: dev, test, or prod'
        required: true
        default: dev
        type: choice
        options:
          - dev
          - test
          - prod
      operation:
        description: 'Operation: update or rollbackCount'
        required: true
        default: update
        type: choice
        options:
          - update
          - rollbackCount
      rollbackCount:
        description: 'Number of changesets to rollback (if operation is rollbackCount)'
        required: false
        default: "1"
      target_db:
        description: 'Database name where changes should be deployed'
        required: true
        default: demo_db

jobs:
  deploy:
    runs-on: ubuntu-latest
    environment: ${{ github.event.inputs.environment }}
    steps:
      # 1. Checkout repository
      - name: Checkout Repo
        uses: actions/checkout@v2

      # 2. Lint SQL files using SQLFluff
      - name: Lint SQL with SQLFluff
        run: |
          pip install sqlfluff==3.2.0
          sqlfluff lint liquibase/ --dialect postgres

      # 3. Set AWS Role ARN based on the selected environment
      - name: Set AWS Role ARN
        id: set_aws_role
        run: |
          if [ "${{ github.event.inputs.environment }}" = "dev" ]; then
            echo "::set-output name=aws_role::$AWS_ROLE_ARN_DEV"
          elif [ "${{ github.event.inputs.environment }}" = "test" ]; then
            echo "::set-output name=aws_role::$AWS_ROLE_ARN_TEST"
          elif [ "${{ github.event.inputs.environment }}" = "prod" ]; then
            echo "::set-output name=aws_role::$AWS_ROLE_ARN_PROD"
          else
            echo "::set-output name=aws_role::$AWS_ROLE_ARN_DEV"
          fi
        env:
          AWS_ROLE_ARN_DEV: ${{ secrets.AWS_ROLE_ARN_DEV }}
          AWS_ROLE_ARN_TEST: ${{ secrets.AWS_ROLE_ARN_TEST }}
          AWS_ROLE_ARN_PROD: ${{ secrets.AWS_ROLE_ARN_PROD }}

      # 4. Configure AWS Credentials using the role ARN from step 3
      - name: Configure AWS Credentials
        uses: aws-actions/configure-aws-credentials@v1
        with:
          role-to-assume: ${{ steps.set_aws_role.outputs.aws_role }}
          aws-region: us-east-1

      # 5. Retrieve DB Secrets from AWS SSM
      - name: Retrieve DB Secrets from SSM
        id: get_secrets
        run: |
          ENV="${{ github.event.inputs.environment }}"
          DB_HOST=$(aws ssm get-parameter --name "/${ENV}/db/DB_HOST" --with-decryption --query 'Parameter.Value' --output text)
          DB_USER=$(aws ssm get-parameter --name "/${ENV}/db/DB_USER" --with-decryption --query 'Parameter.Value' --output text)
          DB_PASS=$(aws ssm get-parameter --name "/${ENV}/db/DB_PASS" --with-decryption --query 'Parameter.Value' --output text)
          # Use the user-specified target_db for DB_NAME.
          DB_NAME="${{ github.event.inputs.target_db }}"
          echo "::set-output name=db_host::$DB_HOST"
          echo "::set-output name=db_user::$DB_USER"
          echo "::set-output name=db_pass::$DB_PASS"
          echo "::set-output name=db_name::$DB_NAME"

      # 6. List Available Databases (optional, for user verification)
      - name: List Databases
        run: |
          sudo apt-get update && sudo apt-get install -y postgresql-client
          echo "Listing databases on host: ${{ steps.get_secrets.outputs.db_host }}"
          psql -h "${{ steps.get_secrets.outputs.db_host }}" -U "${{ steps.get_secrets.outputs.db_user }}" -c "\l"

      # 7. Determine the Liquibase Command based on input
      - name: Set Liquibase Command
        id: set_command
        run: |
          if [ "${{ github.event.inputs.operation }}" = "update" ]; then
            echo "command=update" >> $GITHUB_OUTPUT
          elif [ "${{ github.event.inputs.operation }}" = "rollbackCount" ]; then
            echo "command=rollbackCount ${{ github.event.inputs.rollbackCount }}" >> $GITHUB_OUTPUT
          else
            echo "command=update" >> $GITHUB_OUTPUT
          fi

      # 8. Generate the Liquibase Job Manifest by substituting placeholders
      - name: Generate Liquibase Job Manifest
        run: |
          sed "s|__LIQUIBASE_COMMAND__|${{ steps.set_command.outputs.command }}|g" manifests/liquibase-job-template.yaml > manifests/liquibase-job.yaml
          sed -i "s|__TARGET_DB__|${{ steps.get_secrets.outputs.db_name }}|g" manifests/liquibase-job.yaml
          echo "Generated Liquibase Job Manifest:"
          cat manifests/liquibase-job.yaml

      # 9. Deploy the Liquibase Job and wait for it to complete
      - name: Deploy Liquibase Job
        run: |
          kubectl apply -f manifests/liquibase-job.yaml -n liquibase-demo
          kubectl wait --for=condition=complete job/liquibase-job -n liquibase-demo --timeout=300s
          POD=$(kubectl get pods -n liquibase-demo -l job-name=liquibase-job -o jsonpath="{.items[0].metadata.name}")
          echo "Liquibase Job Logs:"
          kubectl logs $POD -n liquibase-demo

      # 10. Cleanup Liquibase Job
      - name: Cleanup Liquibase Job
        run: kubectl delete job liquibase-job -n liquibase-demo
